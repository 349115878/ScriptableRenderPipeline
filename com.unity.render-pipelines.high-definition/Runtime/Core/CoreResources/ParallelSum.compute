
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CSMainFirst FIRST
#pragma kernel CSMain

#pragma multi_compile VERTICAL HORIZONTAL
#pragma multi_compile SUM_PER_THREAD_2 SUM_PER_THREAD_4 SUM_PER_THREAD_8 SUM_PER_THREAD_16 SUM_PER_THREAD_32 SUM_PER_THREAD_64

// #pragma multi_compile _ GRAYSCALE
// #pragma multi_compile RGBA RGB

#ifdef SUM_PER_THREAD_2
    #define SumPerThread 2
#elif defined(SUM_PER_THREAD_4)
    #define SumPerThread 4
#elif defined(SUM_PER_THREAD_8)
    #define SumPerThread 8
#elif defined(SUM_PER_THREAD_16)
    #define SumPerThread 16
#elif defined(SUM_PER_THREAD_32)
    #define SumPerThread 32
#elif defined(SUM_PER_THREAD_64)
    #define SumPerThread 64
#else
    #error SumPerThread Not defined
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"

  Texture2D<float4> _Input;
RWTexture2D<float4> _Output;

uint4 _Sizes; // xy: InputSize; zw: OutputSize

#define _InputSize  _Sizes.xy
#define _OutputSize _Sizes.zw

#ifdef VERTICAL
    #define THREAD_PER_GROUP_X 1
    #define THREAD_PER_GROUP_Y 8
#else // if HORIZONTAL
    #define THREAD_PER_GROUP_X 8
    #define THREAD_PER_GROUP_Y 1
#endif

#define OutType float

OutType GetInput(uint2 pos)
{
#ifdef FIRST
    return dot(_Input[pos].rgb, float3(1, 1, 1));
#else
    return _Input[pos].r;
#endif
}

OutType GetSample(uint2 id, uint i)
{
#ifdef VERTICAL
    return GetInput(uint2(id.x                 , id.y*SumPerThread + i));
#else
    return GetInput(uint2(id.x*SumPerThread + i, id.y                 ));
#endif
}

float4 ToOutput(OutType v)
{
    return v.xxxx;
}

[numthreads(THREAD_PER_GROUP_X, THREAD_PER_GROUP_Y, 1)]
#ifdef FIRST
void CSMainFirst(uint3 id : SV_DispatchThreadID)
#else
void CSMain     (uint3 id : SV_DispatchThreadID)
#endif
{
    if (all(id.xy < _OutputSize))
    {
        int i;
        OutType sum = 0.0f;
#ifdef FIRST
        const float coef = (1.0f/3.0f)/float(SumPerThread); // div by 3, for rgb & dot product cf. GetSample
#else
        const float coef =  1.0f/float(SumPerThread);
#endif
        for (i = 0; i < SumPerThread; ++i)
        {
            sum += GetSample(id.xy, i)*coef;
        }

        _Output[id.xy] = ToOutput(sum);
    }
}
