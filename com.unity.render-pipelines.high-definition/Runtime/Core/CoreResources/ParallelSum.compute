
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CSMain

// #pragma multi_compile _ GRAYSCALE
// #pragma multi_compile RGBA RGB
#pragma multi_compile VERTICAL HORIZONTAL
#pragma multi_compile SUM_PER_THREAD_2 SUM_PER_THREAD_4 SUM_PER_THREAD_8 SUM_PER_THREAD_16 SUM_PER_THREAD_32 SUM_PER_THREAD_64

#ifdef SUM_PER_THREAD_2
    #define SumPerThread 2
#elif defined(SUM_PER_THREAD_4)
    #define SumPerThread 4
#elif defined(SUM_PER_THREAD_8)
    #define SumPerThread 8
#elif defined(SUM_PER_THREAD_16)
    #define SumPerThread 16
#elif defined(SUM_PER_THREAD_32)
    #define SumPerThread 32
#elif defined(SUM_PER_THREAD_64)
    #define SumPerThread 64
#else
    #error SumPerThread Not defined
#endif

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"

  Texture2D<float4> _Input;
RWTexture2D<float4> _Output;

uint4 _Sizes; // xy: InputSize; zw: OutputSize

#define _InputSizes     _Sizes.xy
#define _OutputSizes    _Sizes.zw

#ifdef VERTICAL
#define THREAD_PER_GROUP_X 1
#define THREAD_PER_GROUP_Y 8
#else // if HORIZONTAL
#define THREAD_PER_GROUP_X 8
#define THREAD_PER_GROUP_Y 1
#endif

// #ifdef GRAYSCALE
//     #define OutType float
// #elif defined(RGB)
//     #define OutType float3
// #elif defined(RGBA)
//     #define OutType float4
// #endif
#define OutType float

OutType GetInput(uint2 pos)
{
// #ifdef GRAYSCALE
//     #ifdef RGB
//         return dot(_Input[pos].rgb,  float3(1, 1, 1));
//     #elif defined(RGBA)
//         return dot(_Input[pos].rgba, float3(1, 1, 1, 1));
//     #endif
// #elif defined(RGB)
//     return _Input[pos].rgb;
// #elif defined(RGBA)
//     return _Input[pos].rgba;
// #endif
    return dot(_Input[pos].rgb, float3(1, 1, 1));
}

OutType GetSample(uint2 id, uint i)
{
#ifdef VERTICAL
    return GetInput(uint2(id.x                 , id.y*SumPerThread + i));
#else
    return GetInput(uint2(id.x*SumPerThread + i, id.y                 ));
#endif
}

float4 ToOutput(OutType v)
{
// #ifdef GRAYSCALE
//     return v.xxxx;
// #elif defined(RGB)
//     return float4(v.rgb, 1.0f);
// #elif defined(RGBA)
//     return v;
// #endif
    return v.xxxx;
}

[numthreads(THREAD_PER_GROUP_X, THREAD_PER_GROUP_Y, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (all(id.xy < _OutputSizes))
    {
        int i;
        OutType sum = 0.0f;
    //#ifdef RGB
            const float coef = (1.0f/float(SumPerThread)/3.0f); // div by 3, for rgb & dot product cf. GetSample
    //#elif defined(RGBA)
    //        const float coef = (1.0f/float(SumPerThread)/4.0f); // div by 4, for rgba & dot product cf. GetSample
    //#endif
        for (i = 0; i < SumPerThread; ++i)
        {
            sum += GetSample(id.xy, i)*coef;
        }

        _Output[id.xy] = ToOutput(sum);
    }
}
