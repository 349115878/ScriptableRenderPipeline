#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CSMainH HORIZONTAL
#pragma kernel CSMainV VERTICAL

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"

  Texture2D<float4> _Input;
RWTexture2D<float4> _Output;

uint4               _Sizes; // xy: InputSize; zw: OutputSize

#define _InputSize  _Sizes.xy
#define _OutputSize _Sizes.zw

[numthreads(8, 8, 1)]
#ifdef HORIZONTAL
void CSMainH(uint3 id : SV_DispatchThreadID)
#else
void CSMainV(uint3 id : SV_DispatchThreadID)
#endif
{
    if (all(id.xy < _OutputSize))
    {
        float4 inVal = _Input[id.xy];
        float  u1    = saturate(_Input[id.xy].x);

        int i;

    #ifdef HORIZONTAL
        float u0 = saturate(_Input[uint2(id.x == 0 ? id.x : id.x - 1, id.y)].x);
        float dp = 1.0f/_OutputSize.x;
        float d  = u1 - u0;
        if (d < dp)
        {
            _Output[uint2(u1*_InputSize.x, id.y)] = saturate(float(id.x)*dp);
        }
        else
        {
            const int maxIter = ceil(d*_InputSize.x);

            const float y0 = float(id.x - 1)*dp;
            const float y1 = float(id.x)*dp;
            const float x0 = float(u0*_InputSize.x);
            const float x1 = float(u1*_InputSize.x);

            const float a  = (y0 - y1)/(x0 - x1);
            const float b  = (x0*y1 - x1*y0)/(x0 - x1);

            for (i = 0; i <= maxIter; ++i)
            {
                //_Output[uint2(u0*_InputSize.x + i, id.y)] = saturate(float(id.x - 1 + i)*dp);
                uint xi = uint(u0*_InputSize.x + i);
                _Output[uint2(xi, id.y)] = saturate(a*float(xi) + b);
            }
        }
    #else
        float u0 = saturate(_Input[uint2(id.x, id.y == 0 ? id.y : id.y - 1)].x);
        float dp = 1.0f/_OutputSize.y;
        float d  = u1 - u0;
        if (d < dp)
        {
            _Output[uint2(id.x, u1*_InputSize.y)] = saturate(float(id.y)*dp);
        }
        else
        {
            const int maxIter = ceil(d*_InputSize.y);

            const float y0 = float(id.y - 1)*dp;
            const float y1 = float(id.y)*dp;
            const float x0 = float(u0*_InputSize.y);
            const float x1 = float(u1*_InputSize.y);

            const float a  = (y0 - y1)/(x0 - x1);
            const float b  = (x0*y1 - x1*y0)/(x0 - x1);

            for (i = 0; i <= maxIter; ++i)
            {
                //_Output[uint2(id.x, u0*_InputSize.y + i)] = saturate(float(id.y - 1 + i)*dp);
                uint xi = uint(u0*_InputSize.y + i);
                _Output[uint2(id.x, xi)] = saturate(a*float(xi) + b);
            }
        }
    #endif
    }
}
