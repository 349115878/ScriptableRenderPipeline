
#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel CSMain

// #pragma multi_compile _ GRAYSCALE
// #pragma multi_compile RGBA RGB
#pragma multi_compile VERTICAL HORIZONTAL

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Macros.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Packing.hlsl"

  Texture2D<float4> _Input;
RWTexture2D<float4> _Output;

uint4 _Sizes; // xy: InputSize; zw: OutputSize

#define _InputSizes     _Sizes.xy
#define _OutputSizes    _Sizes.zw

#ifdef VERTICAL
    #define THREAD_PER_GROUP_X 1
    #define THREAD_PER_GROUP_Y 8
#else // if HORIZONTAL
    #define THREAD_PER_GROUP_X 8
    #define THREAD_PER_GROUP_Y 1
#endif

// #ifdef GRAYSCALE
//     #define OutType float
// #elif defined(RGB)
//     #define OutType float3
// #elif defined(RGBA)
//     #define OutType float4
// #endif
#define OutType float

OutType GetInput(uint2 pos)
{
// #ifdef GRAYSCALE
//     #ifdef RGB
//         return dot(_Input[pos].rgb,  float3(1, 1, 1));
//     #elif defined(RGBA)
//         return dot(_Input[pos].rgba, float3(1, 1, 1, 1));
//     #endif
// #elif defined(RGB)
//     return _Input[pos].rgb;
// #elif defined(RGBA)
//     return _Input[pos].rgba;
// #endif
    return dot(_Input[pos].rgb, float3(1, 1, 1));
}

OutType GetSample(uint2 id, uint i)
{
#ifdef VERTICAL
    return GetInput(uint2(id.x    , id.y + i));
#else
    return GetInput(uint2(id.x + i, id.y    ));
#endif
}

float4 ToOutput(OutType v)
{
// #ifdef GRAYSCALE
//     return v.xxxx;
// #elif defined(RGB)
//     return float4(v.rgb, 1.0f);
// #elif defined(RGBA)
//     return v;
// #endif
    return v.xxxx;
}

[numthreads(THREAD_PER_GROUP_X, THREAD_PER_GROUP_Y, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int i;
    OutType sum = 0.0f;
#ifdef VERTICAL
    int sumCount = _InputSizes.y;
    if (id.y == 0u)
#else
    int sumCount = _InputSizes.x;
    if (id.x == 0u)
#endif
    {
//#ifdef RGB
        const float coef = (1.0f/float(sumCount)/3.0f); // div by 3, for rgb & dot product cf. GetSample
//#elif defined(RGBA)
//        const float coef = (1.0f/float(SumPerThread)/4.0f); // div by 4, for rgba & dot product cf. GetSample
//#endif
        for (i = 0; i < sumCount; ++i)
        {
            sum += GetSample(id.xy, i)*coef;
        }

        for (i = 0; i < 32; ++i)
        {
#ifdef VERTICAL
            _Output[uint2(id.x    , id.y + i)] = ToOutput(sum);
#else
            _Output[uint2(id.x + i, id.y    )] = ToOutput(sum);
#endif
        }
    }
}
