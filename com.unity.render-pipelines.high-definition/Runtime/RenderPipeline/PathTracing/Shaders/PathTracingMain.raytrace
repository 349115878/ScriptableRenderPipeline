// We need N bounces given that we want to support complex light paths
#pragma max_recursion_depth 11

// HDRP include
#define SHADER_TARGET 50

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Color.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Builtin/BuiltinData.hlsl"

// Ray tracing includes
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"

// Path tracing includes
#include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/PathTracing/Shaders/PathTracingSampling.hlsl"

// Input(s)
float4x4 _PixelCoordToViewDirWS;

// Output(s)
RWTexture2D<float4> _CameraColorTextureRW;
RWTexture2D<float4> _AccumulatedFrameTexture;

// Adaptive sampling resources
RW_TEXTURE2D_X(float4, _VarianceTexture);
RW_TEXTURE2D_X(uint, _MaxVariance);
RW_TEXTURE2D_X(uint, _ScratchBuffer);

void AddConvergenceCue(uint2 pixelCoord, uint sampleCount, inout float3 color)
{
    uint width, height;
    _CameraColorTextureRW.GetDimensions(width, height);

    // Change color only in a region corresponding to a progress bar, on the bottom 1% of the screen
    if (pixelCoord.y < 0.01 * height && (float)pixelCoord.x / width <= (float)sampleCount / (_RaytracingNumSamples - 1))
    {
        float lum = Luminance(color);

        if (lum > 1.0)
        {
            color /= lum;
            lum = 1.0;
        }

        // Make dark color brighter, and vice versa
        color += lum > 0.5 ? -0.5 * lum : 0.05 + 0.5 * lum;
    }
}

[shader("miss")]
void Miss(inout RayIntersection rayIntersection : SV_RayPayload)
{
    // Grab depth information
    uint currentDepth = _RaytracingMaxRecursion - rayIntersection.remainingDepth;

    rayIntersection.color = !currentDepth || currentDepth >= _RaytracingMinRecursion ?
        SAMPLE_TEXTURECUBE_ARRAY_LOD(_SkyTexture, s_trilinear_clamp_sampler, WorldRayDirection(), 0.0f, 0) : 0.0;
}


// VARIANCE_ESTIMATE 0: Textbook variance imlpementation, with precision issues: https://en.wikipedia.org/wiki/Variance
// VARIANCE_ESTIMATE 1: Running average implementation described in SVGF paper : https://cg.ivd.kit.edu/publications/2017/svgf/svgf_preprint.pdf
#define VARIANCE_ESTIMATE 1
#define HYSTERISIS  0.12
#define USE_GAMMA_SPACE
#define INVERT_HEATMAP   // When inverted, a red hue means high variance and blue low 
#define ENABLE_ADAPTIVE_SAMPLING

void UpdatePerPixelVariance(uint2 currentPixelCoord, float3 colorIn)
{
#ifdef USE_GAMMA_SPACE
    float L = Luminance(LinearToGamma22(colorIn));
#else
    float L = Luminance(colorIn);
#endif

    uint3 crd = int3(currentPixelCoord, 0);
#if (VARIANCE_ESTIMATE == 0)
    // Note: This version has serious precision issues for large sequences
    _VarianceTexture[crd].x += L;               // first moment
    _VarianceTexture[crd].y += L * L;           // second moment
#elif (VARIANCE_ESTIMATE == 1)
    _VarianceTexture[crd].x = lerp(_VarianceTexture[crd].x, L, HYSTERISIS);     // first moment
    _VarianceTexture[crd].y = lerp(_VarianceTexture[crd].y, L * L, HYSTERISIS); // second moment
#endif
}

float EstimateVariance(uint2 currentPixelCoord)
{
    uint3 crd = int3(currentPixelCoord, 0);
    float value = 0;
    if(_RaytracingFrameIndex > 0)
    {
#if (VARIANCE_ESTIMATE == 0)
        float m_1 = _VarianceTexture[crd].x / _RaytracingFrameIndex;
        m_1 *= m_1;
        value = abs(_VarianceTexture[crd].y / _RaytracingFrameIndex - m_1);
#elif (VARIANCE_ESTIMATE == 1)
        value = 10 * abs(_VarianceTexture[crd].y - _VarianceTexture[crd].x * _VarianceTexture[crd].x);
#endif
    }

    //InterlockedMax(_MaxVariance[uint3(0,0,0)], asint(value));
    return value; 
}

float4 VarianceHeatMap(uint2 currentPixelCoord)
{
    float variance = EstimateVariance(currentPixelCoord);
    float maxVariance = 0.001;  //asfloat(_MaxVariance[uint3(0,0,0)]);
    float minVariance = 0;
    variance = clamp(variance, 0.0, maxVariance);
    // 60% of the hue range goes from red to blue (we don't want magenta in the heatmap)
    float hue =  (0.6 * variance - minVariance)  / (maxVariance - minVariance);
#ifdef INVERT_HEATMAP
    hue = 0.6 - hue;
#endif
    return float4(HsvToRgb(float3(hue, 1.0, 1.0)), 1.0);

}

[shader("raygeneration")]
void RayGen()
{
    const int MIN_ITERATIONS = 32;
    const float VARIANCE_THRESHOLD = 0.00001f;

    uint2 LaunchIndex = DispatchRaysIndex();

    // Get the current pixel coordinates
    uint2 currentPixelCoord = uint2(LaunchIndex.x, LaunchIndex.y);

    uint sampleCount = _RaytracingFrameIndex;

    // Estimate variance
    float variance = 100;
    if(sampleCount > MIN_ITERATIONS)
    {
        variance = EstimateVariance(currentPixelCoord);
    }

    // Did we converge?
    bool converged = (sampleCount > MIN_ITERATIONS) && (variance < VARIANCE_THRESHOLD);
#ifndef ENABLE_ADAPTIVE_SAMPLING
    converged = false;
#endif

    // Should we stop now?
    if ((sampleCount >= _RaytracingNumSamples) || (converged == true) )
    {
        _CameraColorTextureRW[currentPixelCoord] = float4(_AccumulatedFrameTexture[currentPixelCoord].xyz, 1.0);
        return;
    }

    // Clear the variance estimate
    if(sampleCount == 0)
    {
        _MaxVariance[uint3(0,0,0)] = 0.0f;
        //_ScratchBuffer[uint3(0,0,0)] = 0.0f;
        _VarianceTexture[int3(currentPixelCoord, 0)] = float4(0.0, 0.0, 0.0, 0.0);
    }

    // Jitter them
    float3 jitteredPixelCoord = float3(currentPixelCoord, 1.0);
    jitteredPixelCoord.x += GetSample(currentPixelCoord, _RaytracingFrameIndex, 254);
    jitteredPixelCoord.y += GetSample(currentPixelCoord, _RaytracingFrameIndex, 255);

    // Compute the ray direction, from those coordinates
    float3 directionWS = -normalize(mul(jitteredPixelCoord, (float3x3)_PixelCoordToViewDirWS));

    // Create the ray descriptor for this pixel
    RayDesc rayDescriptor;
    rayDescriptor.Origin = _WorldSpaceCameraPos;
    rayDescriptor.Direction = directionWS;
    rayDescriptor.TMin = _RaytracingCameraNearPlane;
    rayDescriptor.TMax = FLT_INF;

    // Create and init the RayIntersection structure for this
    RayIntersection rayIntersection;
    rayIntersection.color = 1.0;
    rayIntersection.remainingDepth = _RaytracingMaxRecursion;
    rayIntersection.pixelCoord = currentPixelCoord;
    rayIntersection.maxRoughness = 0.001;

    // In order to achieve filtering for the textures, we need to compute the spread angle of the pixel
    rayIntersection.cone.spreadAngle = _RaytracingPixelSpreadAngle;
    rayIntersection.cone.width = 0.0;

    // Evaluate the ray intersection
    TraceRay(_RaytracingAccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES | RAY_FLAG_FORCE_OPAQUE, RAYTRACINGRENDERERFLAG_PATH_TRACING, 0, 1, 0, rayDescriptor, rayIntersection);

    // Accumulate the result
    if (sampleCount++)
    {
        rayIntersection.color = (_AccumulatedFrameTexture[currentPixelCoord].xyz * (sampleCount - 1) + rayIntersection.color) / sampleCount;
        UpdatePerPixelVariance(currentPixelCoord, rayIntersection.color);
    }
    _AccumulatedFrameTexture[currentPixelCoord] = float4(rayIntersection.color, 1.0);

    // Add a little convergence cue to our result
    AddConvergenceCue(currentPixelCoord, sampleCount, rayIntersection.color);

    _CameraColorTextureRW[currentPixelCoord] = float4(rayIntersection.color, 1.0);

    // Debug: uncomment for  heatmap visualization
    if(sampleCount > 4)
    {
        _CameraColorTextureRW[currentPixelCoord] = lerp(VarianceHeatMap(currentPixelCoord), _CameraColorTextureRW[currentPixelCoord], 0.4);
    }
}

// This should never be called, return magenta just in case
[shader("closesthit")]
void ClosestHit(inout RayIntersection rayIntersection : SV_RayPayload, AttributeData attributeData : SV_IntersectionAttributes)
{
    rayIntersection.color = float3(1.0, 0.0, 0.5);
}
